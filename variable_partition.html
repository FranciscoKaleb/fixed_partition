<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Variable Partition Simulator</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); padding: 0px; min-height: 100vh; color: #e0e0e0; }
        header { background-color: #2d2d2d; color: white; padding: 20px; text-align: center; margin-bottom: 20px; border-radius: 8px; height: 50px; display: flex; align-items: center; justify-content: center; position: relative; opacity: 0.6; }
        .burger-menu { position: absolute; left: 20px; display: flex; flex-direction: column; gap: 4px; cursor: pointer; }
        .burger-menu span { width: 25px; height: 3px; background-color: white; border-radius: 2px; }
        .side-panel { position: fixed; left: -250px; top: 0; width: 250px; height: 100%; background-color: #2d2d2d; transition: left 0.3s; z-index: 1001; padding-top: 60px; box-shadow: 2px 0 5px rgba(0,0,0,0.5); }
        .side-panel.active { left: 0; }
        .side-panel a { display: block; color: #e0e0e0; padding: 15px 20px; text-decoration: none; border-bottom: 1px solid #444; }
        .side-panel a:hover { background-color: #3d3d3d; }
        .close-panel { position: absolute; top: 15px; right: 20px; font-size: 30px; color: #e0e0e0; cursor: pointer; }
        .close-panel:hover { color: #f44336; }
        .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        .timeline-section { grid-column: 1 / -1; background: linear-gradient(135deg, #2d2d2d 0%, #3d3d3d 100%); padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); margin-top: 20px; }
        .panel { background: linear-gradient(135deg, #2d2d2d 0%, #3d3d3d 100%); padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .step-label { font-size: 18px; font-weight: bold; margin-bottom: 15px; color: #1976d2; }
        .controls { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        input, select { padding: 10px; border: 2px solid #555; border-radius: 4px; background-color: #3d3d3d; color: #e0e0e0; flex: 1; min-width: 100px; }
        button { padding: 10px 15px; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
        button:hover { background-color: #1565c0; }
        button:disabled { background-color: #ccc; cursor: not-allowed; opacity: 0.6; }
        .clear-btn { background-color: #f44336; }
        .clear-btn:hover { background-color: #da190b; }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; background-color: #2d2d2d; }
        th, td { border: 1px solid #444; padding: 12px; text-align: center; color: #e0e0e0; }
        th { background-color: #1e3a5f; color: white; }
        .table-container { max-height: 500px; overflow-y: auto; }
        .table-container::-webkit-scrollbar { width: 6px; }
        .table-container::-webkit-scrollbar-track { background: #1a1a1a; }
        .table-container::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
        .hidden { display: none; }
        .memory-block { background-color: #4CAF50; color: white; font-weight: bold; }
        .memory-block-waiting { background-color: #d32f2f; color: white; font-weight: bold; }
        .free-block { background-color: #666; color: #ccc; }
        .action-buttons { display: flex; gap: 10px; justify-content: center; margin: 20px 0; transition: all 0.3s ease; }
        .action-buttons.glow-blue { box-shadow: 0 0 25px rgba(25, 118, 210, 0.9), 0 0 40px rgba(25, 118, 210, 0.5); border-radius: 8px; padding: 15px; }
        .labels-container { text-align: center; margin: 20px 0; }
        .algorithm-label { font-size: 20px; font-weight: bold; color: #1976d2; }
        .time-display { text-align: center; font-size: 24px; font-weight: bold; margin: 20px 0; }
        .gantt-chart-container { margin: 15px 0; padding: 15px; background: linear-gradient(135deg, #3d3d3d 0%, #4a4a4a 100%); border-radius: 8px; }
        .gantt-chart-container h4 { color: #e0e0e0; margin-bottom: 10px; font-size: 16px; }
        .gantt-chart { display: flex; width: 100%; height: 40px; border: 2px solid #555; border-radius: 4px; overflow: hidden; background-color: #1a1a1a; }
        .gantt-process { display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px; border-right: 1px solid #333; position: relative; }
        .gantt-process:last-child { border-right: none; }
        .gantt-tick-marks { display: flex; width: 100%; position: relative; margin-top: 5px; }
        .gantt-tick { border-left: 2px solid #555; height: 15px; }
        .gantt-tick:last-child { border-right: 2px solid #555; border-left: none; }
        .gantt-number-labels { display: flex; width: 100%; position: relative; margin-top: 5px; }
        .gantt-number-label { font-weight: bold; font-size: 12px; color: #e0e0e0; position: relative; }
        .gantt-number-label:not(:first-child) { margin-left: -10px; }
        .arrival-timeline { margin: 15px 0; padding: 15px; background: linear-gradient(135deg, #3d3d3d 0%, #4a4a4a 100%); border-radius: 8px; }
        .arrival-timeline h4 { color: #e0e0e0; margin-bottom: 10px; font-size: 16px; }
        .arrival-timeline .gantt-chart { position: relative; height: 2px; overflow: visible; background-color: #555; }
        .arrival-timeline .gantt-process { background-color: transparent !important; border: none; height: 2px; position: relative; bottom: 10px; overflow: visible; }
        .arrival-timeline .gantt-tick { border-left: 2px solid #555; height: 15px; position: relative; }
        .arrival-timeline .gantt-tick::before { content: attr(data-process); position: absolute; top: -40px; left: 0; font-size: 12px; font-weight: bold; color: #e0e0e0; }
        .arrival-timeline .gantt-tick::after { content: ''; position: absolute; left: 0; top: -20px; width: 1px; height: 20px; background-color: #e0e0e0; }
        .process-summary { margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #3d3d3d 0%, #4a4a4a 100%); border-radius: 8px; }
        .process-summary p { margin: 5px 0; font-size: 16px; font-weight: bold; color: #e0e0e0; }
        .simulator-card {
    
            padding: 25px;
            background: linear-gradient(135deg, #3d3d3d 0%, #4a4a4a 100%);
            border: 2px solid #555;
            border-radius: 8px;
            text-decoration: none;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            margin-bottom:20px;
        }
        .simulator-card:hover {
            box-shadow: 0 0 20px rgba(25, 118, 210, 0.8), 0 4px 6px rgba(0, 0, 0, 0.3);
            border-color: #1976d2;
        }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); }
        .modal.show { display: flex; justify-content: center; align-items: center; }
        .modal-content { background-color: #2d2d2d; padding: 30px; border-radius: 8px; text-align: center; color: #e0e0e0; border: 2px solid #1976d2; max-width: 400px; box-shadow: 0 0 20px rgba(25, 118, 210, 0.5); }
        .modal-content h2 { color: #1976d2; margin-bottom: 15px; }
        .modal-content button { background-color: #1976d2; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; }
        .modal-content button:hover { background-color: #1565c0; }
        .edit-controls { display: flex; gap: 10px; justify-content: center; margin-top: 15px; }
        .edit-controls button { padding: 10px 20px; font-size: 14px; }
        .delete-btn { background-color: #f44336; padding: 5px 10px; font-size: 12px; }
        .delete-btn:hover { background-color: #da190b; }
        table input { width: 100%; padding: 8px; background-color: #1a1a1a; border: 1px solid #1976d2; color: #e0e0e0; }
        @media (max-width: 768px) { .container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>
    <header>
        <div class="burger-menu" onclick="toggleSidePanel()">
            <span></span>
            <span></span>
            <span></span>
        </div>
        <h1>Variable Partition Memory Simulator</h1>
    </header>
    <div id="sidePanel" class="side-panel">
        <span class="close-panel" onclick="toggleSidePanel()">&times;</span>
        <a href="index.html">About</a>
        <a href="fixed_partition.html">Fixed Partition Simulator</a>
        <a href="variable_partition.html">Variable Partition Simulator</a>
        <a href="buddy_final.html">Buddy System</a>
    </div>
    <div class="container">
        <div class="panel">
            <div class ="simulator-card">
                <div class="step-label">STEP 1: Choose Algorithm</div>
                <div class="controls">
                    <select id="algorithm" onchange="togglePriorityInput()">
                        <option value="FCFS">First Come First Serve (FCFS)</option>
                        <option value="SJF">Shortest Job First (SJF)</option>
                        <option value="NPP">Non-Preemptive Priority (NPP)</option>
                    </select>
                </div>
            </div>

            <div class ="simulator-card">
                <div class="step-label">STEP 2: Set Total Memory Size</div>
                <div class="controls">
                    <input type="number" id="totalMemory" placeholder="Total Memory (KB)" value="22">
                    <button onclick="setMemory()">Set Memory</button>
                </div>
            </div>  
            
            <div class ="simulator-card">
                <div class="step-label">STEP 3: Add Processes</div>
                <div class="controls">
                    <input type="text" id="processName" placeholder="Name">
                    <input type="number" id="arrivalTime" placeholder="Arrival">
                    <input type="number" id="burstTime" placeholder="Burst">
                    <input type="number" id="memoryReq" placeholder="Memory">
                    <input type="number" id="priority" placeholder="Priority" class="hidden">
                </div>
                <div class="controls">
                    <button onclick="addProcess()">Add Process</button>
                    <button onclick="generateSample()" style="background-color: #4CAF50;">Sample Data</button>
                    <button onclick="clearProcesses()" class="clear-btn">Clear All</button>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr id="processTableHeader">
                                <th>Process</th>
                                <th>Arrival</th>
                                <th>Burst</th>
                                <th>Memory</th>
                                <th id="actionsHeader" class="hidden">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="processTable">
                            <tr><td colspan="4">No processes added</td></tr>
                        </tbody>
                    </table>
                </div>
                <div class="edit-controls hidden" id="editControls">
                    <button id="editBtn" onclick="enableEdit()">Edit</button>
                    <button id="saveBtn" onclick="saveEdit()" class="hidden">Save</button>
                    <button id="cancelEditBtn" onclick="cancelEdit()" class="hidden">Cancel</button>
                </div>
            </div>

            
            <div class="controls" style="margin-top: 20px;">
                <button onclick="startSimulation()" style="width: 100%; padding: 15px; font-size: 16px;"> Start Simulation </button>
            </div>
        </div>
        <div class="panel">
            <div class="labels-container hidden" id="labelsContainer">
                <div class="algorithm-label" id="algorithmLabel"></div>
            </div>
            <div class="time-display hidden" id="timeDisplay">
                Current Time: <span id="currentTime">0</span>
            </div>
           
            <div class="table-container simulator-card" style = "height:550px;">
                <table id="memoryTable">
                    <thead>
                        <tr id="memoryTableHeader">
                            <th>Time</th>
                            <th>EF</th>
                            <th>%MU</th>
                            <th>Out</th>
                        </tr>
                    </thead>
                    <tbody id="memoryTableBody">
                    </tbody>
                </table>
            </div>
             <div class="action-buttons hidden" id="actionButtons">
                <button onclick="stepSimulation()">Next Step</button>
                <button onclick="finishSimulation()">Finish</button>
                <button onclick="resetSimulation()">Reset</button>
            </div>
        </div>
    </div>
    <div id="simulationModal" class="modal">
        <div class="modal-content">
            <h2>Simulation Complete</h2>
            <p>Your simulation has finished successfully.</p>
            <button onclick="closeSimulationModal()">Close</button>
        </div>
    </div>
    <div class="timeline-section">
        <div class="arrival-timeline hidden" id="arrivalTimeline">
            <h4>Process Arrival Timeline:</h4>
            <br><br>
            <div class="gantt-chart" id="arrivalChart"></div>
            <div class="gantt-tick-marks" id="arrivalTickMarks"></div>
            <div class="gantt-number-labels" id="arrivalNumberLabels"></div>
        </div>
        <div class="process-summary hidden" id="processSummary">
            <div class="gantt-chart-container" id="ganttChartContainer">
                <h4>Gantt Chart - Process Execution Order:</h4>
                <div class="gantt-chart" id="ganttChart"></div>
                <div class="gantt-tick-marks" id="ganttTickMarks"></div>
                <div class="gantt-number-labels" id="ganttNumberLabels"></div>
            </div>
            <p><strong>Finished Processes:</strong> <span id="finishedProcesses" style="color: #4CAF50;"></span></p>
            <p><strong>Unfinished Processes:</strong> <span id="unfinishedProcesses" style="color: #f44336;"></span></p>
        </div>
    </div>
    <script>
        let processes = [];
        let totalMemory = 22;
        let currentTime = 0;
        let memoryBlocks = [];
        let algorithm = 'FCFS';
        let simulationRunning = false;
        let isPriorityVisible = false;
        let currentlyRunningProcess = null;

        function togglePriorityInput() {
            const algo = document.getElementById('algorithm').value;
            const priorityInput = document.getElementById('priority');
            const tableHeader = document.getElementById('processTableHeader');
            if (algo === 'NPP') {
                priorityInput.classList.remove('hidden');
                isPriorityVisible = true;
                if (!document.getElementById('priorityHeader')) {
                    const th = document.createElement('th');
                    th.textContent = 'Priority';
                    th.id = 'priorityHeader';
                    tableHeader.appendChild(th);
                }
            } else {
                priorityInput.classList.add('hidden');
                isPriorityVisible = false;
                const priorityHeader = document.getElementById('priorityHeader');
                if (priorityHeader) {
                    priorityHeader.remove();
                }
            }
            updateProcessTable();
        }

        function setMemory() {
            const input = document.getElementById('totalMemory');
            totalMemory = parseInt(input.value) || 22;
            alert(`Total memory set to ${totalMemory}KB`);
        }

        function addProcess() {
            const name = document.getElementById('processName').value.trim();
            const arrival = parseInt(document.getElementById('arrivalTime').value);
            const burst = parseInt(document.getElementById('burstTime').value);
            const memory = parseInt(document.getElementById('memoryReq').value);
            const priority = isPriorityVisible ? parseInt(document.getElementById('priority').value) : null;
            if (!name || isNaN(arrival) || isNaN(burst) || isNaN(memory)) {
                alert('Please fill all process fields');
                return;
            }
            if (isPriorityVisible && isNaN(priority)) {
                alert('Please enter priority value');
                return;
            }
            processes.push({
                name: name,
                arrival: arrival,
                burst: burst,
                memory: memory,
                priority: priority,
                remainingBurst: burst,
                allocated: false,
                waiting: false,
                finished: false,
                running: false,
                startTime: -1,
                endTime: -1,
                startAddress: -1
            });
            updateProcessTable();
            clearInputs();
        }

        function clearInputs() {
            document.getElementById('processName').value = '';
            document.getElementById('arrivalTime').value = '';
            document.getElementById('burstTime').value = '';
            document.getElementById('memoryReq').value = '';
            if (isPriorityVisible) {
                document.getElementById('priority').value = '';
            }
        }

        function generateSample() {
            const algo = document.getElementById('algorithm').value;
            if (algo === 'NPP') {
                processes = [
                    {name: 'A7', arrival: 0, burst: 4, memory: 7, priority: 2, remainingBurst: 4, allocated: false, waiting: false, finished: false, running: false, startTime: -1, endTime: -1, startAddress: -1},
                    {name: 'B3', arrival: 1, burst: 3, memory: 3, priority: 1, remainingBurst: 3, allocated: false, waiting: false, finished: false, running: false, startTime: -1, endTime: -1, startAddress: -1},
                    {name: 'C6', arrival: 2, burst: 2, memory: 6, priority: 3, remainingBurst: 2, allocated: false, waiting: false, finished: false, running: false, startTime: -1, endTime: -1, startAddress: -1},
                    {name: 'D6', arrival: 3, burst: 3, memory: 6, priority: 2, remainingBurst: 3, allocated: false, waiting: false, finished: false, running: false, startTime: -1, endTime: -1, startAddress: -1}
                ];
            } else {
                processes = [
                    {name: 'A7', arrival: 0, burst: 4, memory: 7, priority: null, remainingBurst: 4, allocated: false, waiting: false, finished: false, running: false, startTime: -1, endTime: -1, startAddress: -1},
                    {name: 'B3', arrival: 1, burst: 3, memory: 3, priority: null, remainingBurst: 3, allocated: false, waiting: false, finished: false, running: false, startTime: -1, endTime: -1, startAddress: -1},
                    {name: 'C6', arrival: 2, burst: 2, memory: 6, priority: null, remainingBurst: 2, allocated: false, waiting: false, finished: false, running: false, startTime: -1, endTime: -1, startAddress: -1},
                    {name: 'D6', arrival: 3, burst: 3, memory: 6, priority: null, remainingBurst: 3, allocated: false, waiting: false, finished: false, running: false, startTime: -1, endTime: -1, startAddress: -1}
                ];
            }
            updateProcessTable();
        }

        function clearProcesses() {
            processes = [];
            updateProcessTable();
        }

        function updateProcessTable() {
            const tbody = document.getElementById('processTable');
            const editControls = document.getElementById('editControls');
            const actionsHeader = document.getElementById('actionsHeader');
            
            if (processes.length === 0) {
                const colspan = isPriorityVisible ? 5 : 4;
                tbody.innerHTML = `<tr><td colspan="${colspan}">No processes added</td></tr>`;
                editControls.classList.add('hidden');
                actionsHeader.classList.add('hidden');
                return;
            }
            
            tbody.innerHTML = processes.map((p, index) => `
                <tr data-index="${index}">
                    <td class="name-cell">${p.name}</td>
                    <td class="arrival-cell">${p.arrival}</td>
                    <td class="burst-cell">${p.burst}</td>
                    <td class="memory-cell">${p.memory}</td>
                    ${isPriorityVisible ? `<td class="priority-cell">${p.priority !== null ? p.priority : '-'}</td>` : ''}
                    <td class="actions-cell hidden"></td>
                </tr>
            `).join('');
            
            // Show edit button if there are processes
            editControls.classList.remove('hidden');
            document.getElementById('editBtn').classList.remove('hidden');
            document.getElementById('saveBtn').classList.add('hidden');
            document.getElementById('cancelEditBtn').classList.add('hidden');
            actionsHeader.classList.add('hidden');
        }

        function enableEdit() {
            const tbody = document.getElementById('processTable');
            const rows = tbody.querySelectorAll('tr');
            const actionsHeader = document.getElementById('actionsHeader');
            
            rows.forEach((row, index) => {
                const cells = row.querySelectorAll('td');
                const process = processes[index];
                
                // Make each cell an input
                const nameCellContent = cells[0].textContent;
                cells[0].innerHTML = `<input type="text" value="${nameCellContent}" class="edit-name">`;
                
                const arrivalCellContent = cells[1].textContent;
                cells[1].innerHTML = `<input type="number" value="${arrivalCellContent}" class="edit-arrival">`;
                
                const burstCellContent = cells[2].textContent;
                cells[2].innerHTML = `<input type="number" value="${burstCellContent}" class="edit-burst">`;
                
                const memoryCellContent = cells[3].textContent;
                cells[3].innerHTML = `<input type="number" value="${memoryCellContent}" class="edit-memory">`;
                
                if (isPriorityVisible && cells[4]) {
                    const priorityCellContent = cells[4].textContent;
                    cells[4].innerHTML = `<input type="number" value="${priorityCellContent === '-' ? '' : priorityCellContent}" class="edit-priority">`;
                }
                
                // Add delete button to actions cell
                const actionsCell = cells[isPriorityVisible ? 5 : 4];
                actionsCell.innerHTML = `<button class="delete-btn" onclick="deleteProcess(${index})">Delete</button>`;
                actionsCell.classList.remove('hidden');
            });
            
            // Toggle buttons and show actions header
            document.getElementById('editBtn').classList.add('hidden');
            document.getElementById('saveBtn').classList.remove('hidden');
            document.getElementById('cancelEditBtn').classList.remove('hidden');
            actionsHeader.classList.remove('hidden');
        }

        function saveEdit() {
            const tbody = document.getElementById('processTable');
            const rows = tbody.querySelectorAll('tr');
            
            rows.forEach((row, index) => {
                if (index >= processes.length) return;
                
                const inputs = row.querySelectorAll('input');
                const process = processes[index];
                
                process.name = inputs[0].value.trim();
                process.arrival = parseInt(inputs[1].value);
                process.burst = parseInt(inputs[2].value);
                process.memory = parseInt(inputs[3].value);
                
                if (isPriorityVisible && inputs[4]) {
                    process.priority = inputs[4].value !== '' ? parseInt(inputs[4].value) : null;
                }
            });
            
            updateProcessTable();
        }

        function cancelEdit() {
            updateProcessTable();
        }

        function deleteProcess(index) {
            processes.splice(index, 1);
            updateProcessTable();
        }

        function startSimulation() {
            if (processes.length === 0) {
                alert('Please add processes first');
                return;
            }
            algorithm = document.getElementById('algorithm').value;
            currentTime = 0;
            simulationRunning = true;
            currentlyRunningProcess = null;
            memoryBlocks = [{ start: 0, size: totalMemory, process: null, free: true }];
            processes.forEach(p => {
                p.remainingBurst = p.burst;
                p.allocated = false;
                p.waiting = false;
                p.finished = false;
                p.running = false;
                p.startTime = -1;
                p.endTime = -1;
                p.startAddress = -1;
            });
            processes.sort((a, b) => a.arrival - b.arrival);
            document.getElementById('labelsContainer').classList.remove('hidden');
            document.getElementById('timeDisplay').classList.remove('hidden');
            document.getElementById('actionButtons').classList.remove('hidden');
            const algoNames = {
                'FCFS': 'First Come First Serve',
                'SJF': 'Shortest Job First',
                'NPP': 'Non-Preemptive Priority'
            };
            document.getElementById('algorithmLabel').textContent = algoNames[algorithm];
            updateMemoryTableHeader();
            createArrivalTimeline();
            
            // Add glow to action buttons
            const actionButtonsDiv = document.getElementById('actionButtons');
            if (actionButtonsDiv) {
                actionButtonsDiv.classList.add('glow-blue');
            }
        }

        function updateMemoryTableHeader() {
            const header = document.getElementById('memoryTableHeader');
            const memoryHeader = `<th colspan="${totalMemory}">Memory (${totalMemory}k)</th>`;
            header.innerHTML = `
                <th>Time</th>
                ${memoryHeader}
                <th>EF</th>
                <th>%MU</th>
                <th>Waiting</th>
                <th>Out</th>
            `;
        }

        function stepSimulation() {
            if (!simulationRunning) return;

            processes.forEach(p => {
                if (p.arrival === currentTime && !p.allocated && !p.finished) {
                    const allocated = allocateMemory(p);
                    if (!allocated) {
                        p.waiting = true;
                    }
                }
            });

            processes.forEach(p => {
                if (p.waiting && !p.allocated && !p.finished) {
                    const allocated = allocateMemory(p);
                    if (allocated) {
                        p.waiting = false;
                    }
                }
            });

            let runningProcess = null;
            if (currentlyRunningProcess && !currentlyRunningProcess.finished && currentlyRunningProcess.remainingBurst > 0) {
                runningProcess = currentlyRunningProcess;
            } else {
                if (algorithm === 'FCFS') {
                    runningProcess = processes.find(p => p.allocated && p.remainingBurst > 0);
                } else if (algorithm === 'SJF') {
                    const allocated = processes.filter(p => p.allocated && p.remainingBurst > 0);
                    if (allocated.length > 0) {
                        runningProcess = allocated.reduce((min, p) => p.remainingBurst < min.remainingBurst ? p : min );
                    }
                } else if (algorithm === 'NPP') {
                    const allocated = processes.filter(p => p.allocated && p.remainingBurst > 0);
                    if (allocated.length > 0) {
                        runningProcess = allocated.reduce((highest, p) => {
                            if (p.priority < highest.priority) return p;
                            if (p.priority === highest.priority && p.arrival < highest.arrival) return p;
                            return highest;
                        });
                    }
                }
                currentlyRunningProcess = runningProcess;
            }

            processes.forEach(p => {
                p.running = (p === runningProcess);
            });

            if (runningProcess && runningProcess.startTime === -1) {
                runningProcess.startTime = currentTime;
            }

            updateMemoryTable();

            if (runningProcess) {
                runningProcess.remainingBurst--;
                if (runningProcess.remainingBurst === 0) {
                    runningProcess.endTime = currentTime + 1;
                    runningProcess.finished = true;
                    deallocateMemory(runningProcess);
                    currentlyRunningProcess = null;
                }
            }

            currentTime++;
            document.getElementById('currentTime').textContent = currentTime;

            const unfinished = processes.filter(p => !p.finished);
            if (unfinished.length === 0) {
                showProcessSummary();
                simulationRunning = false;
            } else {
                const arrivedUnfinished = unfinished.filter(p => p.arrival <= currentTime);
                if (arrivedUnfinished.length > 0 && arrivedUnfinished.every(p => p.waiting) && !runningProcess) {
                    showProcessSummary();
                    simulationRunning = false;
                }
            }
        }

        function createArrivalTimeline() {
            const arrivalContainer = document.getElementById('arrivalChart');
            const arrivalTickMarks = document.getElementById('arrivalTickMarks');
            const arrivalNumberLabels = document.getElementById('arrivalNumberLabels');
            arrivalContainer.innerHTML = '';
            arrivalTickMarks.innerHTML = '';
            arrivalNumberLabels.innerHTML = '';
            const processGroups = {};
            processes.forEach(process => {
                const arrivalTime = parseInt(process.arrival);
                if (!processGroups[arrivalTime]) {
                    processGroups[arrivalTime] = [];
                }
                processGroups[arrivalTime].push(process.name);
            });
            const sortedTimes = Object.keys(processGroups).map(t => parseInt(t)).sort((a, b) => a - b);
            const maxArrivalTime = Math.max(...sortedTimes);
            let currentTime = 0;
            sortedTimes.forEach((arrivalTime, index) => {
                if (arrivalTime > currentTime) {
                    const gapDiv = document.createElement('div');
                    gapDiv.className = 'gantt-process';
                    gapDiv.style.width = ((arrivalTime - currentTime) / (maxArrivalTime + 1)) * 100 + '%';
                    gapDiv.style.backgroundColor = '#333';
                    gapDiv.style.fontSize = '10px';
                    arrivalContainer.appendChild(gapDiv);
                    const gapTick = document.createElement('div');
                    gapTick.className = 'gantt-tick';
                    gapTick.style.flex = (arrivalTime - currentTime);
                    arrivalTickMarks.appendChild(gapTick);
                    const gapLabel = document.createElement('div');
                    gapLabel.className = 'gantt-number-label';
                    gapLabel.style.flex = (arrivalTime - currentTime);
                    arrivalNumberLabels.appendChild(gapLabel);
                }
                const processDiv = document.createElement('div');
                processDiv.className = 'gantt-process';
                processDiv.style.width = (1 / (maxArrivalTime + 1)) * 100 + '%';
                arrivalContainer.appendChild(processDiv);
                const processTick = document.createElement('div');
                processTick.className = 'gantt-tick';
                processTick.style.flex = 1;
                processTick.setAttribute('data-process', processGroups[arrivalTime].join(', '));
                arrivalTickMarks.appendChild(processTick);
                const processLabel = document.createElement('div');
                processLabel.className = 'gantt-number-label';
                processLabel.style.flex = 1;
                processLabel.textContent = arrivalTime;
                arrivalNumberLabels.appendChild(processLabel);
                currentTime = arrivalTime + 1;
            });
            const finalTick = document.createElement('div');
            finalTick.className = 'gantt-tick';
            arrivalTickMarks.appendChild(finalTick);
            document.getElementById('arrivalTimeline').classList.remove('hidden');
        }

        function createGanttChart() {
            const finishedProcesses = processes.filter(p => p.finished && p.startTime >= 0).sort((a, b) => a.startTime - b.startTime);
            if (finishedProcesses.length === 0) return;
            const ganttContainer = document.getElementById('ganttChart');
            const tickMarksContainer = document.getElementById('ganttTickMarks');
            const numberLabelsContainer = document.getElementById('ganttNumberLabels');
            ganttContainer.innerHTML = '';
            tickMarksContainer.innerHTML = '';
            numberLabelsContainer.innerHTML = '';
            const totalTime = Math.max(...finishedProcesses.map(p => p.endTime));
            const colors = ['#4CAF50', '#2196F3', '#FF9800', '#9C27B0', '#F44336', '#00BCD4', '#FFEB3B', '#795548'];
            let currentTime = 0;
            finishedProcesses.forEach((process, index) => {
                if (process.startTime > currentTime) {
                    const gapDiv = document.createElement('div');
                    gapDiv.className = 'gantt-process';
                    gapDiv.style.width = ((process.startTime - currentTime) / totalTime) * 100 + '%';
                    gapDiv.style.backgroundColor = '#333';
                    gapDiv.textContent = 'IDLE';
                    gapDiv.style.fontSize = '10px';
                    ganttContainer.appendChild(gapDiv);
                    const gapTick = document.createElement('div');
                    gapTick.className = 'gantt-tick';
                    gapTick.style.flex = (process.startTime - currentTime);
                    tickMarksContainer.appendChild(gapTick);
                    const gapLabel = document.createElement('div');
                    gapLabel.className = 'gantt-number-label';
                    gapLabel.style.flex = (process.startTime - currentTime);
                    numberLabelsContainer.appendChild(gapLabel);
                }
                const duration = process.endTime - process.startTime;
                const widthPercent = (duration / totalTime) * 100;
                const processDiv = document.createElement('div');
                processDiv.className = 'gantt-process';
                processDiv.style.width = widthPercent + '%';
                processDiv.style.backgroundColor = colors[index % colors.length];
                processDiv.textContent = process.name;
                ganttContainer.appendChild(processDiv);
                const processTick = document.createElement('div');
                processTick.className = 'gantt-tick';
                processTick.style.flex = duration;
                tickMarksContainer.appendChild(processTick);
                const processLabel = document.createElement('div');
                processLabel.className = 'gantt-number-label';
                processLabel.style.flex = duration;
                processLabel.textContent = process.startTime;
                numberLabelsContainer.appendChild(processLabel);
                currentTime = process.endTime;
            });
            const finalTick = document.createElement('div');
            finalTick.className = 'gantt-tick';
            tickMarksContainer.appendChild(finalTick);
            const finalLabel = document.createElement('div');
            finalLabel.className = 'gantt-number-label';
            finalLabel.textContent = totalTime;
            numberLabelsContainer.appendChild(finalLabel);
        }

        function showProcessSummary() {
            const finished = [];
            const unfinished = [];
            processes.forEach(p => {
                if (p.finished) {
                    finished.push(p.name);
                } else {
                    unfinished.push(p.name);
                }
            });
            createGanttChart();
            const finishedEl = document.getElementById('finishedProcesses');
            finishedEl.textContent = finished.length > 0 ? finished.join(', ') : 'None';
            const unfinishedEl = document.getElementById('unfinishedProcesses');
            unfinishedEl.textContent = unfinished.length > 0 ? unfinished.join(', ') : 'None';
            document.getElementById('processSummary').classList.remove('hidden');
            document.getElementById('actionButtons').classList.add('hidden');
            
            // Remove glow and show modal
            const actionButtonsDiv = document.getElementById('actionButtons');
            if (actionButtonsDiv) {
                actionButtonsDiv.classList.remove('glow-blue');
            }
            document.getElementById('simulationModal').classList.add('show');
        }

        function closeSimulationModal() {
            document.getElementById('simulationModal').classList.remove('show');
        }

        function finishSimulation() {
            while (simulationRunning) {
                stepSimulation();
            }
        }

        function allocateMemory(process) {
            for (let i = 0; i < memoryBlocks.length; i++) {
                const block = memoryBlocks[i];
                if (block.free && block.size >= process.memory) {
                    process.allocated = true;
                    process.startAddress = block.start;
                    if (block.size > process.memory) {
                        memoryBlocks.splice(i + 1, 0, { start: block.start + process.memory, size: block.size - process.memory, process: null, free: true });
                    }
                    block.size = process.memory;
                    block.process = process.name;
                    block.free = false;
                    return true;
                }
            }
            return false;
        }

        function deallocateMemory(process) {
            const blockIndex = memoryBlocks.findIndex(b => b.process === process.name);
            if (blockIndex !== -1) {
                memoryBlocks[blockIndex].free = true;
                memoryBlocks[blockIndex].process = null;
                mergeAdjacentFreeBlocks();
            }
            process.allocated = false;
        }

        function mergeAdjacentFreeBlocks() {
            for (let i = 0; i < memoryBlocks.length - 1; i++) {
                if (memoryBlocks[i].free && memoryBlocks[i + 1].free) {
                    memoryBlocks[i].size += memoryBlocks[i + 1].size;
                    memoryBlocks.splice(i + 1, 1);
                    i--;
                }
            }
        }

        function updateMemoryTable() {
            const tbody = document.getElementById('memoryTableBody');
            const allocatedMemory = memoryBlocks.filter(b => !b.free).reduce((sum, b) => sum + b.size, 0);
            const waitingProcesses = processes.filter(p => p.waiting && !p.finished);
            const waitingProcessNames = waitingProcesses.map(p => p.name).join(', ');
            let externalFragmentation = 0;
            if (waitingProcesses.length > 0) {
                memoryBlocks.forEach(block => {
                    if (block.free) {
                        const canFitAnyWaiting = waitingProcesses.some(p => p.memory <= block.size);
                        if (!canFitAnyWaiting) {
                            externalFragmentation += block.size;
                        }
                    }
                });
            }
            const memoryUtilization = ((allocatedMemory / totalMemory) * 100).toFixed(0);
            const finishedNow = processes.filter(p => p.endTime === currentTime).map(p => p.name).join(', ');
            const memoryViz = memoryBlocks.map(block => {
                if (block.free) {
                    return `<td class="free-block" colspan="${block.size}">${block.size}</td>`;
                } else {
                    const process = processes.find(p => p.name === block.process);
                    const isRunning = process && process.running;
                    const blockClass = isRunning ? 'memory-block' : 'memory-block-waiting';
                    const processMemory = process.memory;
                    const blockSize = block.size;
                    if (processMemory < blockSize) {
                        const processColspan = processMemory;
                        const fragmentColspan = blockSize - processMemory;
                        return `<td class="${blockClass}" colspan="${processColspan}">${block.process}</td><td class="free-block" colspan="${fragmentColspan}" style="background-color: #444;">${fragmentColspan}</td>`;
                    } else {
                        return `<td class="${blockClass}" colspan="${blockSize}">${block.process}</td>`;
                    }
                }
            }).join('');
            const row = `
                <tr>
                    <td>${currentTime}</td>
                    ${memoryViz}
                    <td>${externalFragmentation}</td>
                    <td>${memoryUtilization}%</td>
                    <td>${waitingProcessNames || '-'}</td>
                    <td>${finishedNow || '-'}</td>
                </tr>
            `;
            tbody.innerHTML += row;
        }

        function resetSimulation() {
            currentTime = 0;
            simulationRunning = false;
            memoryBlocks = [];
            currentlyRunningProcess = null;
            document.getElementById('memoryTableBody').innerHTML = '';
            document.getElementById('labelsContainer').classList.add('hidden');
            document.getElementById('timeDisplay').classList.add('hidden');
            document.getElementById('actionButtons').classList.add('hidden');
            document.getElementById('arrivalTimeline').classList.add('hidden');
            document.getElementById('processSummary').classList.add('hidden');
            document.getElementById('currentTime').textContent = '0';
        }

        function toggleSidePanel() {
            document.getElementById('sidePanel').classList.toggle('active');
        }
    </script>
</body>
</html>